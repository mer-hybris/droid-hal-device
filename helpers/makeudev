#!/usr/bin/perl -w

use File::Basename;

# When testing this can help:
# udevadm info --query=all --name=/dev/graphics/fb0
# udevadm test /devices/virtual/graphics/fb0

# From the droid-default-rules in droid-system-packager rpm in
# /lib/udev/rules.d/990-droid-default.rules we get a list of
# subsystem/symlink-dirs which may be referenced
# The key is the target dir created by the udev rule; the value
# is the subsystem.
my %std_subsystem_links = (
			   "graphics" => "graphics",
			   "block" => "block",
			   "dri" => "drm",
			   "oncrpc" => "oncrpc",
			   "adsp" => "adsp",
			   "msm_camera" => "msm_camera",
			   "mtd" => "mtd",
			   "block" => "block",
			   "dvb" => "dvb",
			  );

print "# Generated by the Mer uevent to udev rule generator
# in the droid-hal-* package
#
# This file contains udev rules derived from the uevent.rc
# The original rc file contents are included preceded by #:
#
#
";
my $file="";
while (<>) {
  if ($file ne $ARGV) { # Note where the original .rc entries are from
    $file = $ARGV;
    print "################\n# From ".basename($file)."\n\n";
  }
  print "#:$_";			# after including them
  next if /^\w*#/ or /^\w*$/ ;	# skip comments and blank lines

  # Android .rc files for ueventd /sys are :
  # <devicepath_or_glob>  <attr> <perms>  <owner> <group>
  # This is because uevent only allows a single simple glob within the path
  # Udev handles this by simply concatenating with a /
  # However udev builtins only operate on /dev nodes (AFAICT)
  # Matching is done on events without the /sys/ (which is a userspace
  # convention) but chmod/chown needs the /sys
  # FIXME: consider replacing chmod/chown with an all-in-one to avoid extra exec()s
  if (m{^/sys/}) {
    print "# sys rule\n";
    s{^/sys/}{};
    my ($dev, $key, $mode, $owner, $group) = split;
    print qq{DEVPATH=="/$dev", TEST=="/sys/\$devpath/$key", RUN+="/bin/chmod $mode /sys/\$devpath/$key", RUN+="/bin/chown $owner:$group /sys/\$devpath/$key"\n} ;
    next;
  }

  # Android .rc files for ueventd /dev are :
  # <devicepath_or_glob>  <perms>  <owner> <group>
  if ( s{^/dev/}{} ) {	       # udev doesn't care about /dev ... ever
    my ($dev, $mode, $owner, $group) = split;

    # Handle the Mer/Hybris rename of /dev/log
    if ($dev =~ m{^log/}) {
      print "# Mer/hybris renames /dev/log to /dev/alog (handling as a symlink)\n";
      $dev =~ s{^log/}{alog/};
      print qq{SYMLINK=="$dev", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
      next;
    }

    # For most cases without a / make a plain rule
    if ($dev !~ m{/}) {
      print qq{KERNEL=="$dev", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
      next;
    }

    # skip /dev/input/ because otherwise directories in /dev/input/ get
    # 660 permissions and groups do not have proper permissions to
    # access those.
    # FIXME: better handled by Mer override of droid permissions in udev rules?
    next if m{^input/} ;

    # handle any specific nodes here

    # Remaining nodes with more depth are assumed to be subsystems
    if ($dev =~ m{^([^/\s]*)/([^\s]*)}) {
      my $sub = $1;
      my $rest = $2;

      # Handle the known symlinks generated by:
      # SUBSYSTEM=="graphics", SYMLINK+="$env{SUBSYSTEM}/%k"
      if (defined $std_subsystem_links{$sub}) {
        print "# Known droid dir $std_subsystem_links{$sub}/ is for subsystem $sub\n";
        print qq{SYMLINK=="$dev", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
        print qq{SUBSYSTEM=="$std_subsystem_links{$sub}", KERNEL=="$rest", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
        if ($sub eq "block") {
          if ($rest =~ m{.*/(.*)}) {
            # Make sure we set the permissions on the device, not on a symlink to it.
            print qq{SUBSYSTEM=="$std_subsystem_links{$sub}", DEVLINKS=="* $rest *|$rest *|* $rest|$rest", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
          }
        }
        next;
      }

      # udev requires that "bus" is literally replaced with "subsystem"
      # but we ignore it in usb anyway
      # I wonder if we should reparse bus/* after stripping bus/ ???
      $sub = "subsystem" if $sub eq "bus";

      # handle /dev/bus/usb*
      if ( $rest =~ m{^usb/(.*)} ) {
	print "# usb rule\n";
	print qq{SUBSYSTEM=="usb", KERNEL=="$1", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
	next;
      }

      # Any Multi-level devices need to be handled above as per usb
      if ($rest =~ m{/}) {
	die "Can't handle unknown multi-level devices\n$_\n";
      }

      # handle any unknowns
      print "# Standard subsystem rule\n";
      print qq{SUBSYSTEM=="$1", KERNEL=="$2", MODE="$mode", GROUP="$group", OWNER="$owner"\n} ;
      next;
    }
  }

  if (m{^mtd@}) {
    print STDERR "WARNING \@mtd support not yet implemented (see system/core/init/ueventd.c\n";
  }

  print "# WARNING rule in comment above was not converted\n";
  print STDERR "WARNING Rule not converted: $_\n";
}

# Some tests:
# Make a little helper fn()
# tdev() { udevadm info --query=all --name=$1; udevadm test $(udevadm info --query=path --name=$1); grep $1 /lib/udev/rules.d/999-android-system.rules; ls -laF $1; }

# tdev /dev/android_adb
# tdev /dev/graphics/fb0
# tdev /dev/bus/usb/001/001
# tdev /dev/cam

# filter out relevant lines
# tdev /dev/android_adb 2>&1 | grep 999
